#!/usr/bin/python3
from Piraha import *
import sys, os
from random import randint, seed
import argparse

parser = argparse.ArgumentParser(description='The Mnemosyne Interpreter')
parser.add_argument('--seed', type=int, default=randint(0,1000000), help='set the random seed')
parser.add_argument('--bw', action='store_true', default=False, help='disable text coloring')
parser.add_argument('--dbg', action='store_true', default=False, help='turn on debugging')
parser.add_argument('file', type=str, help='A Mnemosyne source file')
pres=parser.parse_args(sys.argv[1:])

DIV = '::'
files = {}
logfd = open("log.txt","w")
sval = pres.seed
print("seed=%d" % sval,file=logfd)
seed(sval)
debug = False

path_to_mnemo = os.path.dirname(os.path.realpath(sys.argv[0]))
mnemo_path = [path_to_mnemo, "."]
if "MNEMO_PATH" in os.environ:
    mnemo_path += os.environ["MNEMO_PATH"].split(":")

if pres.bw:
    def colored(x,_):
        return x
else:
    from termcolor import colored

INDENT = "  "

threads = []

g = Grammar()
compileFile(g,os.path.join(mnemo_path[0],"mnemo.peg"))
with open(pres.file) as fd:
    fc = fd.read()
files[fc] = sys.argv[1]
m = Matcher(g,g.default_rule,fc)
if m.matches():
    pass #print(m.gr.dump())
else:
    m.showError()
    raise Exception()

def filename(group):
    return files[group.text]

def loadstr(item):
    if type(item) == list:
        return "Array[%d]" % len(item)
    elif type(item) == dict:
        return "Struct[]"
    else:
        return str(item)

class Func:
    def __init__(self,addr):
        self.addr = addr
    def __repr__(self):
        return "Func(%d)" % self.addr

class BadAddress:
    pass

class Var:
    def __init__(self,name,val,qual):
        self.name = name
        self.val = val
        self.oldval = None
        self.qual = qual
        self.finished = True
    def check(self):
        assert self.qual in ["atomic","const","regular","safe"]
    def set(self,v):
        self.finished = False
        self.oldval = self.val
        if self.val is None:
            self.val = v
        else:
            assert self.qual != "const", "Attempt to set a constant variable"
            self.val = v
    def get(self):
        if self.finished:
            return self.val
        elif self.qual == "atomic":
            if randint(1,3) == 1:
                self.oldval = self.val
            return self.oldval
        elif self.qual == "regular":
            if randint(1,2) == 1:
                return self.oldval
            else:
                return self.val
        elif self.qual == "safe":
            if type(self.val) == int:
                val = randint(-1000,1000)
            elif type(self.val) == float:
                val = 2000*(random()-.5)
            else:
                val = BadAddress()
            return val
        else:
            raise Exception(self.qual)
    def __repr__(self):
        return "Var(%s,%s)" % (self.qual, type(self.val).__name__ )
    def storeFinish(self):
        self.finished = True

thread_seq = 0

class Interp:
    def getvar(self,vname):
        if vname in self.vars[-1][vname]:
            return self.vars[-1][vname]
        elif vname in self.vars[0][vname]:
            return self.vars[0][vname]
        else:
            self.massert(false,"Invalid variable: '%s'" % vname)

    def addr(self,f):
        self.massert(hasattr(f,"addr"),"Not a function object: "+str(f))
        return f.addr
        
    def done(self):
        return len(self.stack) == 0

    def __init__(self,gr):
        global thread_seq

        self.id = thread_seq
        thread_seq += 1

        self.trace = True
        self.gr = gr
        self.pc = -1
        self.stack = []
        self.rets = []
        self.vars = [
            {"true":Var("true",True,"const"),
             "false":Var("false",False,"const"),
             "none":Var("none",None,"const")}]
        self.loads = [{}]
        self.inst = []
        self.indent = 0
        self.delay = 0
        for i in range(gr.groupCount()):
            self.load_instructions(gr.group(i))

        # Find functions
        for i in range(len(self.inst)):
            gm = self.inst[i][0]
            nm = gm.getPatternName() 
            if nm == "start_fn":
                fnm = gm.group(0).substring()
                self.vars[0][fnm] = Var("fname",Func(i+1),"const")

        self.load_sys_functions(os.path.join(mnemo_path[0],"lib/sys.mn"))

    def load_sys_functions(self,fname):
        with open(fname,"r") as fd:
            fc = fd.read()
        files[fc] = fname
        m2 = Matcher(g,g.default_rule,fc)
        if not m2.matches():
            m2.showError()
        for k in range(m2.gr.groupCount()):
            elem = m2.gr.group(k) 
            nm = elem.getPatternName()
            if nm == "fun_def":
                func = elem.group(0).group(0).substring()
                ind = len(self.inst)+1
                self.vars[0][func] = Var("fun_def",Func(ind),"const")
                self.load_instructions(elem)

    def diag(self):
        # Diagnostic of the instruction set
        for i in range(len(self.inst)):
            print(colored(str(i)+":","yellow"),end=' ')
            nm = self.inst[i][0].getPatternName()
            if nm in ["load", "store", "assign"]:
                print(colored(nm,"red"),self.inst[i][0].substring(),end=' ')
            else:
                print(colored(nm,"red"),end=' ')
            for j in range(1,len(self.inst[i])):
                print(colored(self.inst[i][j],"green"),end=' ')
            print()
        print('=====')

    def load_instructions(self,group):
        nm = group.getPatternName()
        if nm == "var" or nm == "fun":
            for i in range(group.groupCount()):
                self.load_instructions(group.group(i))
            load = Group("load",group.text,group.start,group.end)
            load.children += [group]
            self.inst += [(load,)]
        elif nm == "breakstmt" or nm == "continue":
            self.inst += [(group,)]
        elif nm == "ifstmt":
            prelist = []
            ilist = []
            glist = []
            for i in range(group.groupCount()):
                g = group.group(i)
                nm = g.getPatternName()
                if nm in ["else","elif"]:
                    glist += [len(self.inst)]
                    self.inst += [(Group("goto","",0,0),)]
                n1 = len(self.inst)
                self.load_instructions(group.group(i))
                if nm in ["if","elif","else","end"]:
                    n2 = len(self.inst)-1
                    prelist += [n1]
                    ilist += [n2]
            for k in range(len(ilist)-1):
                k1 = ilist[k]
                k2 = prelist[k+1]
                self.inst[k1] = (self.inst[k1][0], k2)
            k1 = ilist[-1]
            k2 = ilist[0]
            self.inst[k1] = (self.inst[k1][0], k2)
            for g in glist:
                self.inst[g] = (self.inst[g][0], k1)
        elif nm == "assign" or nm == "def":
            self.load_instructions(group.group(2))
            self.inst += [(group,)]
            if nm == "assign":
                store = Group("store",group.text,group.start,group.end)
                store.children += [group.group(0)]
                self.inst += [(store,)]
        elif nm in ["expr", "val", "num", "op", "array", "str", "name", "args", "vals", "body", "real", "elem", "alloc", "qual", "struct", "pairs", "pair", "sizer", "memcall"]:
            for i in range(group.groupCount()):
                self.load_instructions(group.group(i))
        elif nm in ["start_fn", "end", "returnstmt", "for", "if", "elif", "else", "import", "while"]:
            for i in range(group.groupCount()):
                self.load_instructions(group.group(i))
            self.inst += [(group,)]
        elif nm in ["fun_def", "forstmt", "whilestmt"]:
            fstart = len(self.inst)
            for i in range(group.groupCount()):
                self.load_instructions(group.group(i))
                if i == 0:
                    i0 = len(self.inst)-1
            endptr = len(self.inst)-1
            assert self.inst[endptr][0].getPatternName() == "end"
            if nm == "whilestmt":
                self.inst[i0] = (self.inst[i0][0], endptr) # point to end
            else:
                self.inst[fstart] = (self.inst[fstart][0], endptr) # point to end
            if nm == "forstmt":
                self.inst[endptr] = (self.inst[endptr][0], i0) # point to start
            else:
                self.inst[endptr] = (self.inst[endptr][0], fstart) # point to start
        else:
            raise Exception(nm)
    def getval(self,expr):
        nm = expr.getPatternName()
        if nm == "expr":
            if expr.groupCount() == 1:
                return self.getval(expr.group(0))
            elif expr.groupCount() == 3:
                val1 = self.getval(expr.group(0))
                t1 = type(val1)
                op = expr.group(1).substring()
                val2 = self.getval(expr.group(2))
                t2 = type(val2)
                if t1 == int and t2 == float:
                    val1 = float(val1)
                    t1 = float
                elif t1 == float and t2 == int:
                    val2 = float(val2)
                    t2 = float
                if op == "+":
                    return val1+val2
                elif op == "-":
                    return val1-val2
                elif op == "*":
                    return val1*val2
                elif op == "/":
                    if [t1,t2]==[int,int]:
                        return val1//val2
                    else:
                        return val1/val2
                elif op == "==":
                    return val1==val2
                elif op == "<":
                    return val1<val2
                elif op == ">":
                    return val1>val2
                elif op == "<=":
                    return val1<=val2
                elif op == ">=":
                    return val1>=val2
                elif op == "!=":
                    return val1!=val2
                elif op == "and":
                    return val1 and val2
                elif op == "or":
                    return val1 or val2
                elif op == "%":
                    return val1 % val2
                raise Exception("op="+op)
        elif nm == "val":
            return self.getval(expr.group(0))
        elif nm == "num":
            return int(expr.substring())
        elif nm == "str":
            sval = expr.substring()
            return sval[1:-1]
        elif nm == "var" or nm == "fun":
            return self.loads[-1][expr.start]
        elif nm == "real":
            return float(expr.substring())
        elif nm == "alloc":
            qual = expr.group(0).substring()
            vals = expr.group(1)
            vnm  = expr.group(1).getPatternName()
            if vnm == "array":
                ar = []
                for i in range(vals.groupCount()):
                    ar += [Var("&",self.getval(vals.group(i)),qual)]
            elif vnm == "struct":
                d = {}
                hash = vals.group(0)
                for i in range(hash.groupCount()):
                    pair = self.getval(hash.group(i))
                    pair[1].qual = qual
                    d[pair[0]] = pair[1]
                return d
            elif vnm == "sizer":
                ar = []
                count = self.getval(vals.group(0))
                item = self.getval(vals.group(1))
                for i in range(count):
                    ar += [Var("&",item,qual)]
                return ar
            else:
                raise Exception(vnm)
            return ar
        elif nm == "pair":
            v0 = self.getval(expr.group(0))
            v1 = self.getval(expr.group(1))
            var1 = Var('&',v1,"const")
            return [v0, var1]
        elif nm == "memcall":
            dvar = self.getval(expr.group(0))
            return dvar[expr.group(1).substring()]
        elif nm == "pairs" or nm == "vals":
            ar = []
            for k in range(expr.groupCount()):
                ar += self.getval(expr.group(k))
            return ar

        raise Exception(nm)
    def massert(self,test,msg):
        if not test:
            self.die(msg)
    def die(self,msg):
        print("Die:",msg)
        self.stack += [self.pc] # Add current location to the stack
        for k in range(len(self.stack)-1,-1,-1):
            pc = self.stack[k]
            if pc < len(self.inst):
                pg = self.inst[pc][0]
                print(" at file '%s' line %d: %s" % (filename(pg), pg.linenum(), pg.substring()))
        #raise Exception("die")
        exit(0)
    def start_call(self,expr,retkey):
        global threads, debug
        ####
        fnm = expr.group(0).substring()
        if fnm == "print" or fnm == "println":
            vals = expr.group(1)
            for i in range(vals.groupCount()):
                print(self.getval(vals.group(i)),end='')
            if fnm == "println":
                print()
            self.pc += 1
            return True
        elif fnm == "pyexec":
            vals = expr.group(1)
            args = []
            self.pc += 1
            retval = None
            for k in range(vals.groupCount()):
                args += [ self.getval(vals.group(k)) ]
            eglobs = {"retval":None,"args":args,"Var":Var}
            exec(args[0],{},eglobs)
            retval = eglobs["retval"]
            if type(retval) == list:
                retval = [Var('&',di,'const') for di in retval]
            self.loads[-1][retkey] = retval
            return True
        elif fnm == "trace":
            vals = expr.group(1)
            val = self.getval(vals.group(0))
            if val == True:
                self.trace = True
            elif val == False:
                self.trace = False
            else:
                raise Exception(val)
            self.pc += 1
            return True
        elif fnm == "assert":
            self.pc += 1
            vals = expr.group(1)
            val = self.getval(vals.group(0))
            if val != True:
                self.die("Assertion failure: "+vals.substring())
            return True
        elif fnm == "spawn":
            vals = expr.group(1)
            newthread = Interp(self.gr)
            newthread.trace = debug
            newthread.indent = 0
            for k in self.vars[0].keys():
                newthread.vars[0][k] = self.vars[0][k]
            newthread.pc = len(self.inst)
            newthread.start_call(vals,expr.start)
            threads += [newthread]
            self.pc += 1
            vid = Var("id",newthread.id,"const")
            self.loads[-1][retkey] = newthread.id # vid
            return True
        elif fnm == "is_alive":
            self.pc += 1
            vals = expr.group(1)
            pid = self.getval(vals.group(0))
            found = False
            for th in threads:
                if pid == th.id:
                    found = True
                    break
            vid = found # Var("alive",found,"const")
            self.loads[-1][retkey] = vid
            return
        elif fnm == "len":
            self.pc += 1
            vals = self.getval(expr.group(1))
            self.loads[-1][retkey] = len(vals)
            return
        elif fnm == "CAS":
            self.pc += 1
            vals = expr.group(1)
            vname = expr.group(1).group(0).substring()
            if vname in self.vars[-1]:
                var = self.vars[-1][vname]
            elif vname in self.vars[0]:
                var = self.vars[0][vname]
            else:
                self.die("CAS: No such variable: "+vname)
            self.massert(type(var.val) == list,"Arg 0 of CAS must be a list")
            self.massert(len(var.val) > 0,"Array arg of CAS must have length of 1 or more")
            self.massert(var.val[0].qual == "atomic","Arg 0 of CAS must be atomic")
            oldval = self.getval(vals.group(1))
            newval = self.getval(vals.group(2))
            if var.val[0].val == oldval:
                var.val[0].val = newval
                var.val[0].storeFinish()
                retval = True
            else:
                retval = False
            self.loads[-1][retkey] = retval
            return
        ####
        mfnm = expr.group(0).getPatternName()
        add_self = 0
        # Why is this sometimes expr?
        if mfnm == "expr" or mfnm == "name":
            fname = expr.group(0).substring()
            try:
                funinst = self.addr(self.vars[0][fname].get())
            except KeyError as ke:
                self.die(str(ke))
        elif mfnm == "memcall":
            add_self = 1
            fname = expr.group(0).substring()
            vname = expr.group(0).group(0).substring()
            funinst = self.addr(self.getval(expr.group(0)).get())
        else:
            raise Exception(mfnm)
        if self.trace:
            print(INDENT * self.indent,colored(str(self.id)+": ","blue"),colored("start call: ","green"),colored(fname,"blue"),sep='')
        if pres.dbg and fname == "main":
            debug = True
        print(str(self.id),DIV,"start call: ",fname,sep='',file=logfd)
        self.indent += 1
        funval = self.inst[funinst-1][0]
        argdefs = funval.group(1)
        argvals = expr.group(1)
        n1 = argdefs.groupCount()
        n2 = argvals.groupCount()+add_self
        self.massert(n1 == n2,"Arity mismatch for '"+fname+"()' %d != %d" % (n1,n2))
        self.vars += [{}]
        for i in range(argdefs.groupCount()):
            argname = argdefs.group(i).substring()
            if add_self == 1 and i == 0:
                argval = self.getval(expr.group(0).group(0))
            else:
                argval = self.getval(argvals.group(i-add_self))
            argvar = Var(argname, argval, "const")
            self.vars[-1][argname] = argvar
        self.loads += [{}]
        self.stack += [self.pc]
        self.rets += [retkey]
        self.pc = funinst
    def end_call(self,retval):
        self.indent -= 1
        self.pc = self.stack[-1]+1
        retkey = self.rets[-1]

        self.stack = self.stack[:-1]
        self.vars = self.vars[:-1]
        self.loads = self.loads[:-1]
        self.rets = self.rets[:-1]

        self.loads[-1][retkey] = retval
        if self.trace:
            print(INDENT * self.indent,colored(str(self.id)+": ","blue"),colored("end call->%s" % (loadstr(retval)),"green"),sep='')
        print(str(self.id),DIV,"end call->%s" % (loadstr(retval)),sep='',file=logfd)
    def step(self,feedback):
        global threads
        assert self.pc >= 0,str(self.pc)
        feedback[0] = False
        if self.pc >= len(self.inst):
            return False
        if self.delay > 0:
            if self.trace:
                print(INDENT*self.indent,colored("%d: " % self.id,"blue"),colored("delay","green"),sep='')
            print("%d: " % self.id,"delay",sep='',file=logfd)
            self.delay -= 1
            return True
        s = self.inst[self.pc][0]
        nm = s.getPatternName()
        if nm == "load":
            if self.trace:
                print(INDENT*self.indent,colored(str(self.id)+": ","blue"),colored("line: "+str(s.linenum()),"green")," ",colored("load: "+s.substring(),"blue"),sep='',end=' ')
            print(str(self.id),DIV,"line: "+str(s.linenum())," ","load: "+s.substring(),sep='',end=' ',file=logfd)
        elif nm == "start_fn":
            pass #print(colored("step: "+str(self.pc),"green"),colored("define function: "+s.substring(),"blue"))
            feedback[0] = True
        elif nm == "store":
            if self.trace:
                print(INDENT*self.indent,colored(str(self.id)+": ","blue"),colored("line: "+str(s.linenum()),"green")," ",colored("finish: "+s.substring(),"blue"),sep='')
            print(str(self.id)+": ","line: "+str(s.linenum())," ","finish: "+s.substring(),sep='',file=logfd)
        elif nm == "assign":
            if self.trace:
                print(INDENT*self.indent,colored(str(self.id)+": ","blue"),colored("line: "+str(s.linenum()),"green")," ",colored("start: "+s.substring(),"blue"),sep='')
            print(str(self.id),DIV,"line: "+str(s.linenum())," ","start: "+s.substring(),sep='',file=logfd)
        else:
            if self.trace:
                print(INDENT*self.indent,colored(str(self.id)+": ","blue"),colored("line: "+str(s.linenum()),"green")," ",colored(s.substring(),"blue"),sep='')
            print(str(self.id),DIV,"line: "+str(s.linenum())," ",s.substring(),sep='',file=logfd)
        if nm == "start_fn":
            self.pc = self.inst[self.pc][1]+1
            return True
        elif nm == "load":
            if s.group(0).getPatternName() == "var":
                vg = s.group(0)
                if vg.group(0).getPatternName() == "name":
                    vname = vg.substring()
                    elems = []
                else:
                    elg = vg.group(0)
                    vname = elg.group(0).substring()
                    elems = elg.group(1).children
                if vname in self.vars[-1]:
                    var = self.vars[-1][vname]
                elif vname in self.vars[0]:
                    var = self.vars[0][vname]
                else:
                    self.die('No variable named: '+vname)
                for ch in elems:
                    chv = self.getval(ch)
                    var = var.get()[chv]
                val = var.get()
                self.loads[-1][s.group(0).start] = val
                if self.trace:
                    print(colored("-> "+loadstr(val),"yellow"))
                print("-> "+loadstr(val),file=logfd)
                self.pc += 1
                return True
            elif s.group(0).getPatternName() == "fun":
                expr = s.group(0)
                if self.trace:
                    print()
                print(file=logfd)
                self.start_call(expr,s.start)
                return True
            else:
                raise Exception()
        elif nm == "def":
            qual = s.group(0).substring()
            val = self.getval(s.group(2))
            if s.group(1).getPatternName() == "var":
                vname = s.group(1).substring()
                self.massert(vname not in self.vars[-1],"Redefinition of "+vname+" at line  "+str(s.linenum()))
                var = Var(vname,val,qual)
                self.vars[-1][vname] = var
                self.pc += 1
                return True
        elif nm == "assign":
            op = s.group(1).substring()
            val = self.getval(s.group(2))
            self.delay = randint(0,2)
            nm = s.group(0).getPatternName()
            if nm == "var":
                vname = s.group(0).substring()
                if op == ":=":
                    self.massert(vname not in self.vars[-1],"Redefinition of "+vname+" at line  "+str(s.linenum()))
                    var = Var(vname,val)
                    self.vars[-1][vname] = var
                    self.pc += 1
                    return True
                elif op == "=":
                    self.massert((vname in self.vars[-1]) or (vname in self.vars[0]),"Undefined variable '"+vname+"' at line "+str(s.linenum()))
                    if vname in self.vars[-1]:
                        var = self.vars[-1][vname]
                    else:
                        var = self.vars[0][vname]
                    var.set(val)
                    self.store_var = var
                    self.pc += 1
                    return True
                else:
                    raise Exception(op)
            elif nm == "elem":
                self.pc += 1
                lhs = s.group(0)
                vname = lhs.group(0).substring()
                if vname in self.vars[-1]:
                    var = self.vars[-1][vname]
                else:
                    var = self.vars[0][vname]
                for i in range(1,lhs.groupCount()):
                    ind = self.getval(lhs.group(i))
                    try:
                        var = var.get()[ind]
                    except IndexError as ie:
                        self.die(str(ie))
                rhs = self.getval(s.group(2))
                op = s.group(1).substring()
                if op == "=":
                    self.store_var = var
                    var.set(rhs)
                    return True
                raise Exception()
            else:
                raise Exception(nm)
        elif nm == "end":
            if len(self.stack) == 0:
                return False
            step_info = self.inst[self.pc]
            endix = step_info[1]
            start_info = self.inst[endix]
            ends = start_info[0].getPatternName()
            if ends == "start_fn":
                self.end_call(None)
            elif ends == "if":
                self.pc += 1
            elif ends == "for":
                loopvar = start_info[0].group(0).substring()
                startval = self.getval(start_info[0].group(1))
                endval = self.getval(start_info[0].group(2))
                oldval = self.vars[-1][loopvar].get()
                if oldval < endval:
                    self.vars[-1][loopvar] = Var(loopvar,oldval+1,"const")
                    self.pc = endix
                else:
                    del self.vars[-1][loopvar]
                self.pc += 1
            elif ends == "load":
                # This is a while statement
                self.pc = step_info[1]
            else:
                raise Exception(ends)
            return True
        elif nm == "returnstmt":
            retval = self.getval(s.group(0))
            self.end_call(retval)
            return True
        elif nm == "for":
            loopvar = s.group(0).substring()
            startval = self.getval(s.group(1))
            endval = self.getval(s.group(2))
            self.massert(loopvar not in self.vars[-1],"Loop attempts to redefine "+loopvar)
            self.vars[-1][loopvar] = Var(loopvar,startval,"const")
            self.pc += 1
            return True
        elif nm == "if" or nm == "elif":
            bval = self.getval(s.group(0))
            self.massert(type(bval) == bool, "If expression does not evaluate to boolean "+s.substring())
            if bval:
                self.pc += 1
                return True
            else:
                self.pc = self.inst[self.pc][1]
                return True
        elif nm == "else":
            self.pc += 1
            return True
        elif nm == "goto":
            self.pc = self.inst[self.pc][1]
            return True
        elif nm == "import":
            fname = self.getval(s.group(0))
            vals = s.group(1)
            funs = []
            for i in range(vals.groupCount()):
                funs += [vals.group(i).substring()]

            # Locate path
            for path in mnemo_path:
                ftemp = os.path.join(path, fname)
                if os.path.exists(ftemp):
                    fname = ftemp
                    break

            with open(fname,"r") as fd:
                fc = fd.read()

            # Import
            files[fc] = fname
            m2 = Matcher(g,g.default_rule,fc)
            if not m2.matches():
                m2.showError()
            for k in range(m2.gr.groupCount()):
                elem = m2.gr.group(k) 
                nm = elem.getPatternName()
                if nm == "fun_def":
                    func = elem.group(0).group(0).substring()
                    if func in funs:
                        ind = len(self.inst)+1
                        self.vars[0][func] = Var("fun_def",Func(ind),"const")
                        self.load_instructions(elem)
                        #print("fdef:",func,"->",ind,self.inst[ind][0].dump())
            self.pc += 1
            return True
        elif nm == "store":
            self.store_var.storeFinish()
            self.pc += 1
            return True
        elif nm == "while":
            val = self.getval(s.group(0))
            if val == True:
                self.pc += 1
            elif val == False:
                self.pc = self.inst[self.pc][1] + 1
            else:
                raise Exception(val)
            return True
        elif nm == "breakstmt" or nm == "continue":
            while self.pc < len(self.inst):
                step_info = self.inst[self.pc]
                if step_info[0].getPatternName() == "end":
                    endix = step_info[1]
                    start_info = self.inst[endix]
                    if start_info[0].getPatternName() == "for":
                        #ends = start_info[0].getPatternName()
                        if nm == "breakstmt":
                            loopvar = start_info[0].group(0).substring()
                            del self.vars[-1][loopvar]
                            self.pc += 1
                        return True
                    elif start_info[0].getPatternName() in ["load", "while"]:
                        if nm == "breakstmt":
                            self.pc += 1
                        return True
                self.pc += 1
            return True
        raise Exception(s.dump())
        return False

## BEGIN MAIN CODE

interp = Interp(m.gr)

threads += [interp]

interp.pc = 0

def run_step():
    global debug
    while True:
        lo = 0
        hi = len(threads)-1
        if hi < 0:
            return False
        if lo == hi:
            tno = lo
        else:
            tno = randint(lo, hi)

        # The debugger
        if debug:
            while True:
                print('$ ',end='')
                sys.stdout.flush()
                cmd = sys.stdin.readline()
                if cmd == "":
                    debug = False
                    break
                rm = re.match(r'\s*step\s+(\d+)',cmd)
                if rm:
                    tnum = int(rm.group(1))
                    tinp = None
                    for k in range(len(threads)):
                        if threads[k].id == tnum:
                            tinp = k
                    if tinp is None:
                        print(colored("No such thread: "+rm.group(1),"red"),end=' threads: ')
                        for t in threads:
                            print(t.id,end=' ')
                        print()
                    else:
                        tno = tinp
                        break

        thread = threads[tno]
        feedback = [False]
        if not thread.step(feedback):
            del threads[tno]
        else:
            while feedback[0]:
                if not thread.step(feedback):
                    break
            return True

def addgr(gr,sgr,ss):
    g = Group(sgr,ss,0,len(ss))
    gr.children += [g]
    return g

while run_step():
    pass

if "main" in interp.vars[0]:

    # Need to re-add the thread before calling main
    threads += [interp]

    mainloc = interp.addr(interp.vars[0]["main"].get())
    maing = interp.inst[mainloc-1][0]
    main_arg_count = maing.group(1).groupCount()
    #interp.vars += [{}]
    expr = Group("fun","",0,0)
    addgr(expr,"name","main")
    vals = addgr(expr,"vals","")
    if main_arg_count == 1:
        alloc = addgr(vals,"alloc","")
        addgr(alloc,"qual","const")
        array = addgr(alloc,"array","")
        for a in sys.argv:
            addgr(array,"str",'"'+a+'"')
    interp.start_call(expr,0)
    while run_step():
        pass
    retval = interp.loads[-1][0]
    if retval is None:
        exit(0)
    elif type(retval) == int:
        exit(retval)
    else:
        raise Exception("return from main not an int: "+str(retval))
